arr[0]=":q[uit]\nQuit Vim. This fails when changes have been made.\n"
arr[1]=":q[uit]!\nQuit without writing.\n"
arr[2]=":q[uit]\nQuit Vim.  This fails when changes have been made.\n"
arr[2]=":q[uit]!\nQuit without writing.\n"
arr[2]=":cq[uit]\nQuit always, without writing.\n"
arr[2]=":wq\nWrite the current file and exit.\n"
arr[2]=":wq!\nWrite the current file and exit always.\n"
arr[2]=":wq {file}\nWrite to {file}.  Exit if not editing the last\n"
arr[2]=":wq! {file}\nWrite to {file} and exit always.\n"
arr[2]=":[range]wq[!]\n[file]  Same as above, but only write the lines in [range].\n"
arr[2]="ZZ\nWrite current file, if modified, and exit.\n"
arr[2]="ZQ\nQuit current file and exit (same as ":q!").\n"
arr[2]=":e[dit]\nEdit the current file.  This is useful to re-edit the current file, when it has been changed outside of Vim.\n"
arr[2]=":e[dit]!\nEdit the current file always.  Discard any changes to the current buffer.  This is useful if you want to start all over again.\n"
arr[2]=":e[dit] {file}\nEdit {file}.  \n"
arr[2]=":e[dit]! {file}\nEdit {file} always.  Discard any changes to the current buffer.\n"
arr[2]="gf\nEdit the file whose name is under or after the cursor.  Mnemonic: "goto file".\n"
arr[2]="a\nAppend text after the cursor [count] times.\n"
arr[2]="A\nAppend text at the end of the line [count] times.\n"
arr[2]="i\nInsert text before the cursor [count] times.\n"
arr[2]="I\nInsert text before the first non-blank in the line [count] times.\n"
arr[2]="gI\nInsert text in column 1 [count] times.\n"
arr[2]="o\nBegin a new line below the cursor and insert text, repeat [count] times.\n"
arr[2]="O\nBegin a new line above the cursor and insert text, repeat [count] times.\n"
arr[2]=":r[ead] [name]\nInsert the file [name] below the cursor.\n"
arr[2]=":r[ead] !{cmd}\nExecute {cmd} and insert its standard output below the cursor. \n"
arr[2]="&lt;Del&gt; or\nDelete [count] characters under and after the cursor\n"
arr[2]="X\nDelete [count] characters before the cursor\n"
arr[2]="d{motion}\nDelete text that {motion} moves over \n"
arr[2]="dd\nDelete [count] lines\n"
arr[2]="D\nDelete the characters under the cursor until the end of the line\n"
arr[2]="{Visual}x  or\nDelete the highlighted text (for {Visual} see \n"
arr[2]="{Visual}CTRL-H   or\nWhen in Select mode: Delete the highlighted text\n"
arr[2]="{Visual}X  or\nDelete the highlighted lines \n"
arr[2]=":[range]d[elete]\nDelete [range] lines (default: current line)\n"
arr[2]=":[range]d[elete] {count}\nDelete {count} lines, starting with [range]\n"
arr[2]="r{char}\nreplace the character under the cursor with {char}.\n"
arr[2]="R\nEnter Insert mode, replacing characters rather than inserting\n"
arr[2]="~\nSwitch case of the character under the cursor and move the cursor to the right.  If a [count] is given, do that many characters.\n"
arr[2]="~{motion}\nswitch case of {motion} text.\n"
arr[2]="{Visual}~\nSwitch case of highlighted text\n"
arr[2]=":[range]s[ubstitute]/{pattern}/{string}/[c][e][g][p][r][i][I] [count]\nFor each line in [range] replace a match of {pattern} with {string}.\n:[range]s[ubstitute] [c][e][g][r][i][I] [count] :[range]&[c][e][g][r][i][I] [count]\nRepeat last :substitute with same search pattern and substitute string, but without the same flags.  You may add extra flags\nThe arguments that you can use for the substitute commands:\n[c]  Confirm each substitution.  Vim positions the cursor on the matching string. You can type:\n      'y'      to substitute this match\n'n'      to skip this match\n      <Esc>   to skip this match\n      'a'      to substitute this and all remaining matches {not in Vi}\n      'q'      to quit substituting {not in Vi}\n      CTRL-E  to scroll the screen up {not in Vi}\n      CTRL-Y  to scroll the screen down {not in Vi}.\n[e]     When the search pattern fails, do not issue an error message and, in\n particular, continue in maps as if no error occurred.\n[g]  Replace all occurrences in the line.  Without this argument, replacement occurs only for the first occurrence in each line.\n[i]  Ignore case for the pattern.\n[I]  Don't ignore case for the pattern.\n[p]  Print the line containing the last substitute.\n"
arr[2]="\"{a-zA-Z0-9.%#:-\"}\nUse register {a-zA-Z0-9.%#:-\"} for next delete, yank or put (use uppercase character to append with delete and yank) ({.%#:} only work with put).\n"
arr[2]=":reg[isters]\nDisplay the contents of all numbered and named registers.\n"
arr[2]=":reg[isters] {arg}\nDisplay the contents of the numbered and named registers that are mentioned in {arg}.  \n"
arr[2]=":di[splay] [arg]\nSame as :registers. \n"
arr[2]="[\"x]y{motion}\nYank {motion} text [into register x].\n"
arr[2]="[\"x]yy\nYank [count] lines [into register x]\n"
arr[2]="[\"x]Y\nyank [count] lines [into register x] (synonym for yy).\n"
arr[2]="{Visual}[\"x]y\nYank the highlighted text [into register x] (for {Visual} see \n"
arr[2]="{Visual}[\"x]Y\nYank the highlighted lines [into register x]\n"
arr[2]=":[range]y[ank] [x]\nYank [range] lines [into register x].\n"
arr[2]=":[range]y[ank] [x] {count}\nYank {count} lines, starting with last line number in [range] (default: current line), [into register x].\n"
arr[2]="[\"x]p\nPut the text [from register x] after the cursor [count] times.\n"
arr[2]="[\"x]P\nPut the text [from register x] before the cursor [count] times.\n"
arr[2]="[\"x]gp\nJust like "p", but leave the cursor just after the new text.\n"
arr[2]="[\"x]gP\nJust like "P", but leave the cursor just after the new text.\n"
arr[3]=":[line]pu[t] [x]\nPut the text [from register x] after [line] (default current line).\n"
arr[4]=":[line]pu[t]! [x]\nPut the text [from register x] before [line] (default current line).\n"
arr[2]="u\nUndo [count] changes. \n"
arr[2]=":u[ndo]\nUndo one change. \n"
arr[2]="CTRL-R\nRedo [count] changes which were undone. \n"
arr[2]=":red[o]\nRedo one change which was undone. \n"
arr[4]="U\nUndo all latest changes on one line.  {Vi: while not moved off of {t}\n"
arr[2]=".\nRepeat last change, with count replaced with [count].\n"
arr[2]="Basic motion commands\n\n  k            <up>\n h     <left>    <right>\n  j           <down>\n"

arr[2]="h  or\n[count] characters to the left (exclusive).\n"
arr[2]="l or\n[count] characters to the right (exclusive).\n"
arr[2]="k  or\n[count] lines upward\n"
arr[2]="j or\n[count] lines downward (linewise).\n"
arr[2]="0\nTo the first character of the line (exclusive). \n"
arr[2]="&lt;Home&gt;\nTo the first character of the line (exclusive). \n"
arr[2]="^\nTo the first non-blank character of the line\n"
arr[2]="$  or\nTo the end of the line and [count - 1] lines downward\n"
arr[2]="g0 or\nWhen lines wrap ('wrap on): To the first character of the screen line (exclusive).  Differs from "0" when a line is wider than the screen.  When lines don't wrap ('wrap' off): To the leftmost character of the current line that is on the screen.  Differs from "0" when the first character of the line is not on the screen.\n"
arr[2]="g^\nWhen lines wrap ('wrap' on): To the first non-blank character of the screen line (exclusive).  Differs from "^" when a line is wider than the screen.  When lines don't wrap ('wrap' off): To the leftmost non-blank character of the current line that is on the screen.  Differs from "^" when the first non-blank character of the line is not on the screen. \n"
arr[2]="g$ or\nWhen lines wrap ('wrap' on): To the last character of the screen line and [count - 1] screen lines downward (inclusive).  Differs from "$" when a line is wider than the screen.  When lines don't wrap ('wrap' off): To the rightmost character of the current line that is visible on the screen.  Differs from "$" when the last character of the line is not on the screen or when a count is used.\n"
arr[2]="f{char}\nTo [count]'th occurrence of {char} to the right.  The cursor is placed on {char} (inclusive).\n"
arr[2]="F{char}\nTo the [count]'th occurrence of {char} to the left.  The cursor is placed on {char} (inclusive).\n"
arr[2]="t{char}\nTill before [count]'th occurrence of {char} to the right.  The cursor is placed on the character left of {char} (inclusive).\n"
arr[2]="T{char}\nTill after [count]'th occurrence of {char} to the left.  The cursor is placed on the character right of {char} (inclusive).\n"
arr[2]=";\nRepeat latest f, t, F or T [count] times.\n"
arr[2]=",\nRepeat latest f, t, F or T in opposite direction [count] times.\n"
arr[3]="-  &lt;minus&gt;\n[count] lines upward, on the first non-blank character\n"
arr[4]="+ or<br> CTRL-M or<br> &lt;CR&gt;\n[count] lines downward, on the first non-blank character (linewise).\n"
arr[2]="_  &lt;underscore&gt;\n[count] - 1 lines downward, on the first non-blank character (linewise).\n"
arr[2]="&lt;C-End&gt; or\nGoto line [count], default last line, on the first non-blank character.\n"
arr[2]="&lt;C-Home&gt;  or\nGoto line [count], default first line, on the first non-blank character.\n"
arr[2]="&lt;S-Right&gt;  or\n[count] words forward \n"
arr[2]="&lt;C-Right&gt;  or\n[count] WORDS forward \n"
arr[2]="e\nForward to the end of word [count] \n"
arr[2]="E\nForward to the end of WORD [count] \n"
arr[2]="&lt;S-Left&gt;  or\n[count] words backward \n"
arr[2]="&lt;C-Left&gt;  or\n[count] WORDS backward \n"
arr[2]="ge\nBackward to the end of word [count] \n"
arr[2]="gE\nBackward to the end of WORD [count]\n"
arr[2]="(\n[count] sentences backward\n"
arr[2]=")\n[count] sentences forward \n"
arr[2]="{\n[count] paragraphs backward\n"
arr[2]="}\n[count] paragraphs forward \n"
arr[3]="]]\n[count] sections forward or to the next '{' in the first column.  When used after an operator, then the '}' in the first column.\n"
arr[2]="][\n[count] sections forward or to the next '}' in the first column \n"
arr[3]="[[\n[count] sections backward or to the previous '{' in the first column\n"
arr[2]="[]\n[count] sections backward or to the previous '}' in the first column \n"
arr[2]="z.\nCenter the screen on the cursor\n"
arr[2]="zt\nScroll the screen so the cursor is at the top\n"
arr[2]="zb\nScroll the screen so the cursor is at the bottom\n"
arr[2]="m{a-zA-Z}\nSet mark {a-zA-Z} at cursor position (does not move the cursor, this is not a motion command).\n"
arr[2]="m'  or\nSet the previous context mark.  This can be jumped to with the "''" or "``" command (does not move the cursor, this is not a motion command).\n"
arr[2]=":[range]ma[rk] {a-zA-Z}\nSet mark {a-zA-Z} at last line number in [range], column 0.  Default is cursor line.\n"
arr[2]=":[range]k{a-zA-Z}\nSame as :mark, but the space before the mark name can be omitted.\n"
arr[2]="'{a-z}\nTo the first non-blank character on the line with mark {a-z} (linewise).\n"
arr[2]="'{A-Z0-9}\nTo the first non-blank character on the line with mark {A-Z0-9} in the correct file\n"
arr[2]="`{a-z}\nTo the mark {a-z}\n"
arr[2]="`{A-Z0-9}\nTo the mark {A-Z0-9} in the correct file\n"
arr[2]=":marks\nList all the current marks (not a motion command).\n"
arr[2]=":marks {arg}\nList the marks that are mentioned in {arg} (not a motion command).  For example:\n"
arr[2]="/{pattern}[/]\nSearch forward for the [count]'th occurrence of {pattern}\n"
arr[2]="/{pattern}/{offset}\nSearch forward for the [count]'th occurrence of {pattern} and go {offset} lines up or down.\n"
arr[2]="/&lt;CR&gt;\nSearch forward for the [count]'th latest used pattern\n"
arr[2]="//{offset}&lt;CR&gt;\nSearch forward for the [count]'th latest used pattern with new.  If {offset} is empty no offset is used.\n"
arr[2]="?{pattern}[?]&lt;CR&gt;\nSearch backward for the [count]'th previous occurrence of {pattern} \n"
arr[2]="?{pattern}?{offset}&lt;CR&gt;\nSearch backward for the [count]'th previous occurrence of {pattern} and go {offset} lines up or down \n"
arr[2]="?&lt;CR&gt;\nSearch backward for the [count]'th latest used pattern \n"
arr[2]="??{offset}&lt;CR&gt;\nSearch backward for the [count]'th latest used pattern with new {offset}.  If {offset} is empty no offset is used.\n"
arr[2]="n\nRepeat the latest "/" or "?" [count] times.\n"
arr[2]="N\nRepeat the latest "/" or "?" [count] times in opposite direction.  \n"


rand=$[$RANDOM % ${#arr[@]}]
echo ${arr[$rand]}
